---
title: <<汇编语言>>第4~6章笔记
date: 2018-05-24 17:18:21
tags: [notes, assembly language]
---
## 伪指令
伪指令是由编译器来执行的指令，编译器根据伪指令来进行相关的编译操作
### segment和ends
segment和ends是一对成对使用的伪指令，用来定义一个段，segment说明一个段的开始，ends结束。一个段必须由一个名称来标识，使用格式为：
```
段名 segment
...
段名 ends
```
### end
end 通知编译器程序的入口和结束
```
# 示例
start:
      代码段
end start
```
### assume
这条伪指令的含义为“假设”。它假设某一段寄存器和程序中某一个用segment...ends定义的段相关联。通过这条指令，编译程序可以将段寄存器和一个具体的段相关联
>**note** : 具体关联还是要依靠汇编指令的实现，CPU并不知道assume

### db、dw、dd
db定义字节型数据
dw定义字型数据
dd定义双字型数据

### dup
dup是一个操作符，同db、dw、dd等一样，也是由编译器识别处理的符号。它配合db、dw、dd等数据定义使用，用来进行数据的重复
```
# 示例
db 3 dup (0) # 相当于db 0, 0, 0
db 3 dup(0, 1, 2) #定义了九个字节，它们是0、1、2、0、1、2、0、1、2
db 3 dup('abc', 'ABC')
# 定义了18个字节，它们是'abcABCabcABCabcABC'
```
dup 使用格式为
db 重复次数 dup (重复的字节型数据)
dw 重复次数 dup (重复的字型数据)
dd 重复次数 dup (重复的双字型数据)

### 操作符offset
操作符offset在汇编语言中是由编译器处理的符号，用来取得标号的偏移地址。
```
#示例
assume cs:codeesg
codesg segment
    start : mov ax, offset start # 相当于mov ax, 0
    s     : mov ax, offset s     # 相当于mov ax, 3
codeesg ends
end start
```

## DOS系统中.exe文件程序的加载过程
![exe文件程序的加载过程](https://upload-images.jianshu.io/upload_images/10461798-62cad12cd6bd8b52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
## loop指令和CX寄存器
CPU执行loop指令的操作：
1. （cx) = (cx) - 1
2. 判断cx的值，如果不为零则跳至标号处执行程序，为零则继续向下执行。

```
# 使用方法
mov cx, 循环次数
s:
  循环执行的代码段
  loop s
```

>**note** : loop指令实现循环功能，cx存放循环次数

## 段前缀
在指令“mov ax, [bx]"中，段地址默认在ds中，我们可以在访问内存单元的指令中显示地给出内存单元所在的段地址。比如：
```
mov ax, cs:[bx]
mov ax, ss:[bx]
```
**cs:、ss:**这些显示给出段地址的在汇编语言中被称为**段前缀**
